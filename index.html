<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Simulateur Projection Mapping</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; padding: 0; background: #f4f4f4; display: flex; flex-direction: column; align-items: center; }
    .container { display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 1920px; }
    .sections { display: flex; flex-direction: row; width: 100%; justify-content: space-around; margin-bottom: 2rem; }
    .section { padding: 1rem; border-radius: 6px; box-shadow: 0 0 5px rgba(0,0,0,0.1); width: 22%; }
    .section.building { background: #e0f7fa; }
    .section.projector { background: #e8f5e9; }
    .section.thresholds { background: #fff3e0; }
    .section.manual { background: #ffe5e5; }
    .section.results { background: #fff; }
    fieldset { padding: 0.75rem; border-radius: 6px; background: #fff; box-shadow: 0 0 5px rgba(0,0,0,0.1); }
    legend { font-weight: bold; }
    label { display: block; margin: 0.5rem 0; }
    input, select, button { padding: 0.4rem; font-size: 1rem; }
    #feedback { margin-top: 1rem; padding: 0.5rem; border-radius: 4px; color: #800; background: #fee; display: none; }
    #canvas-container { display: flex; flex-direction: row; align-items: center; width: 100%; }
    #canvas-container canvas { background: #eee; border: 1px solid #ccc; }
    #results-container { display: flex; flex-direction: column; align-items: flex-start; width: 33%; }
    #results { white-space: pre-wrap; margin-top: 1rem; background: #fff; padding: 1rem; border-radius: 6px; box-shadow: 0 0 5px rgba(0,0,0,0.1); width: 100%; }
    #legend { margin-top: 1rem; padding: 10px; border-radius: 5px; box-shadow: 0 0 5px rgba(0,0,0,0.1); background: #fff; }
    .footer { margin-top: 2rem; width: 100%; text-align: center; padding: 1rem; background: #e0e0e0; border-top: 2px solid #ccc; }
    #temp-results { white-space: pre-wrap; margin-top: 1rem; background: #f0f0f0; padding: 1rem; border-radius: 6px; box-shadow: 0 0 5px rgba(0,0,0,0.1); width: 100%; display: none; }
  </style>
</head>
<body>

  <div class="container">
    <div class="sections">
      <div class="section building">
        <fieldset>
          <legend>Bâtiment</legend>
          <label>Largeur (m) : <input type="number" id="bldgW" step="0.01" value="40"></label>
          <label>Hauteur (m): <input type="number" id="bldgH" step="0.01" value="15"></label>
        </fieldset>
      </div>

      <div class="section projector">
        <fieldset>
          <legend>Projecteur & Orientation</legend>
          <label>Aspect ratio :
            <select id="aspect">
              <option value="16/9">16:9</option>
              <option value="16/10" selected>16:10</option>
            </select>
          </label>
          <label>Résolution (px) : W <input type="number" id="resW" value="1920" style="width:5rem;">
                                × H <input type="number" id="resH" value="1200" style="width:5rem;"></label>
          <label>Lumens : <input type="number" id="lumens" value="20000"></label>

          <fieldset style="margin:1rem 0; padding:0.5rem; border:1px solid #ccc; border-radius:4px;">
            <legend>Mode orientation</legend>
            <label><input type="radio" name="orientMode" value="auto" checked> Auto</label>
            <label><input type="radio" name="orientMode" value="land"> Paysage</label>
            <label><input type="radio" name="orientMode" value="port"> Portrait</label>
          </fieldset>
        </fieldset>
      </div>

      <div class="section thresholds">
        <fieldset>
          <legend>Projection & Seuils</legend>
          <label>Distance fixe (m) : <input type="number" id="dist" step="0.1" value="50"></label>
          <label>Lux minimum (lx) : <input type="number" id="minLux" step="1" value="100"></label>
          <label>Pixel max (mm) : <input type="number" id="maxPixel" step="0.1" value="20"></label>
          <label>Overlap horiz. (%) : <input type="number" id="ovx" step="1" value="10"></label>
          <label>Overlap vert. (%)  : <input type="number" id="ovy" step="1" value="10"></label>
        </fieldset>
      </div>

      <div class="section manual">
        <fieldset>
          <legend>Réglage manuel</legend>
          <label>Colonnes : <input type="number" id="manCols" min="1"></label>
          <label>Rangées  : <input type="number" id="manRows" min="1"></label>
          <button onclick="manualUpdate()">Mettre à jour le rendu</button>
        </fieldset>
      </div>
    </div>

    <button onclick="runSimulation()">Calculer & Afficher</button>

    <div id="feedback"></div>

    <div id="canvas-container">
      <canvas id="cv" width="1280" height="720"></canvas>
      <div id="results-container">
        <div id="results"></div>
        <div id="temp-results"></div>
        <div id="legend">
          <p>Légende :</p>
          <p style="background:#9cffac;">1 projecteur</p>
          <p style="background:#00ff00;">2 projecteurs (Dual)</p>
          <p style="background:#00b200;">3 projecteurs (Trial)</p>
          <p style="background:#006b00;">4 projecteurs (Quadral)</p>
          <p style="background:#d8bfd8;">5 projecteurs</p>
          <p style="background:#ba68c8;">6 projecteurs</p>
          <p style="background:#9c27b0;">7 projecteurs</p>
          <p style="background:#4a148c;">8 projecteurs</p>
        </div>
      </div>
    </div>

    <div class="footer">
      <p>Zone de développement pour la représentation 3D de la simulation</p>
    </div>
  </div>

<script>
// Specs Epson EB-PU2220B
const SENSOR_DIAG_IN = 0.67, IN_TO_MM = 25.4;
const SENSOR_RATIO = 16/10;
const SENSOR_W = SENSOR_DIAG_IN * (SENSOR_RATIO/Math.hypot(SENSOR_RATIO,1)) * IN_TO_MM;

// configuration optimale
let layout = null;
let tempLayout = null;

// relance auto si on change l'orientation
document.querySelectorAll('input[name="orientMode"]').forEach(el=>
  el.addEventListener('change', runSimulation)
);

function showFeedback(msg) {
  const fb = document.getElementById('feedback');
  fb.textContent = msg;
  fb.style.display = msg ? 'block' : 'none';
}

function validateInputs() {
  // récupère et vérifie
  const BW   = parseFloat(document.getElementById('bldgW').value);
  const BH   = parseFloat(document.getElementById('bldgH').value);
  const resW = parseFloat(document.getElementById('resW').value);
  const resH = parseFloat(document.getElementById('resH').value);
  const lum  = parseFloat(document.getElementById('lumens').value);
  const D    = parseFloat(document.getElementById('dist').value);
  const minL = parseFloat(document.getElementById('minLux').value);
  const maxP = parseFloat(document.getElementById('maxPixel').value);
  const ovX  = parseFloat(document.getElementById('ovx').value);
  const ovY  = parseFloat(document.getElementById('ovy').value);

  if (!BW || BW <= 0)  return "Largeur du bâtiment invalide.";
  if (!BH || BH <= 0)  return "Hauteur du bâtiment invalide.";
  if (!resW || resW <= 0) return "Résolution largeur invalide.";
  if (!resH || resH <= 0) return "Résolution hauteur invalide.";
  if (!lum || lum <= 0)   return "Lumens invalide.";
  if (!D || D <= 0)       return "Distance de projection invalide.";
  if (minL < 0)           return "Lux minimum doit être ≥ 0.";
  if (maxP <= 0)          return "Pixel max doit être > 0.";
  if (ovX < 0 || ovX >= 100) return "Overlap horizontal entre 0 et <100%.";
  if (ovY < 0 || ovY >= 100) return "Overlap vertical entre 0 et <100%.";
  return null;
}

function runSimulation(){
  showFeedback("");

  // validation
  const err = validateInputs();
  if (err) {
    showFeedback(err);
    return;
  }

  // lecture des paramètres
  const BW    = +document.getElementById('bldgW').value;
  const BH    = +document.getElementById('bldgH').value;
  const [aW,aH] = document.getElementById('aspect').value.split('/').map(Number);
  const resW  = +document.getElementById('resW').value;
  const resH  = +document.getElementById('resH').value;
  const lum   = +document.getElementById('lumens').value;
  const D     = +document.getElementById('dist').value;
  const minLux= +document.getElementById('minLux').value;
  const maxPx = +document.getElementById('maxPixel').value;
  const ovX   = +document.getElementById('ovx').value/100;
  const ovY   = +document.getElementById('ovy').value/100;
  const oMode = document.querySelector('input[name="orientMode"]:checked').value;

  // fonction qui teste col→rows pour un aspect donné
  function compute(ratio) {
    let best = null;
    for (let cols = 1; cols <= 20; cols++) {
      const imgW = BW / (1 + (cols - 1) * (1 - ovX));
      const imgH = imgW * ratio;
      const rows = Math.ceil(BH / (imgH * (1 - ovY)));
      const tot  = cols * rows;
      const pxW  = imgW * 1000 / resW;
      const pxH  = imgH * 1000 / resH;
      const luxA = lum * tot / (BW * BH);
      const tr   = D / imgW;
      const foc  = tr * SENSOR_W;
      const cfg  = { cols, rows, tot, imgW, imgH, pxW, pxH, luxA, throw: tr, focale: foc };
      // priorise ceux qui passent les seuils
      if (Math.max(pxW, pxH) <= maxPx) {
        if (!best || cfg.tot < best.tot || (cfg.tot === best.tot && cfg.luxA > best.luxA)) {
          best = cfg;
        }
      }
      // si aucun ne passe, on prendra plus tard le meilleur tot minimal
      if (!best && (cols === 20)) {
        // rechute : sans seuils
        best = cfg;
      }
    }
    return best;
  }

  // test paysage & portrait
  const land = compute(aH / aW);
  const port = compute(aW / aH);

  // Ajout de la logique pour couvrir entièrement le bâtiment
  const coverLand = {
    cols: Math.ceil(BW / (BW / (1 + (land.cols - 1) * (1 - ovX)))),
    rows: Math.ceil(BH / (BH / (1 + (land.rows - 1) * (1 - ovY))))
  };
  const coverPort = {
    cols: Math.ceil(BW / (BW / (1 + (port.cols - 1) * (1 - ovX)))),
    rows: Math.ceil(BH / (BH / (1 + (port.rows - 1) * (1 - ovY))))
  };

  if (oMode === 'auto') {
    layout = coverLand.tot <= coverPort.tot
      ? { ...land, orientation: 'Paysage', cols: coverLand.cols, rows: coverLand.rows }
      : { ...port, orientation: 'Portrait', cols: coverPort.cols, rows: coverPort.rows };
  } else if (oMode === 'land') {
    layout = { ...land, orientation: 'Paysage', cols: coverLand.cols, rows: coverLand.rows };
  } else {
    layout = { ...port, orientation: 'Portrait', cols: coverPort.cols, rows: coverPort.rows };
  }

  // Ajout de la logique pour les duals/trials/quadrals
  let multiplier = 1;
  while (layout.luxA < minLux && multiplier < 8) {
    multiplier++;
    layout.luxA = lum * layout.tot * multiplier / (BW * BH);
  }
  layout.multiplier = multiplier;

  // Calcul de l'espace pixélaire
  const netWidth = layout.imgW * layout.cols * resW * (1 - ovX);
  const netHeight = layout.imgH * layout.rows * resH * (1 - ovY);
  const grossWidth = layout.imgW * layout.cols * resW;
  const grossHeight = layout.imgH * layout.rows * resH;

  layout.netResolution = `${netWidth.toFixed(0)} x ${netHeight.toFixed(0)}`;
  layout.grossResolution = `${grossWidth.toFixed(0)} x ${grossHeight.toFixed(0)}`;

  // mise à jour champs manuels
  document.getElementById('manCols').value = layout.cols;
  document.getElementById('manRows').value = layout.rows;

  // affichage
  drawCanvas(false);
  showResults();
}

function manualUpdate() {
  if (!layout) {
    showFeedback("⚠️ Lancez d'abord « Calculer & Afficher » avant le réglage manuel.");
    return;
  }
  showFeedback("");

  // lecture des paramètres manuels
  const BW    = +document.getElementById('bldgW').value;
  const BH    = +document.getElementById('bldgH').value;
  const [aW,aH] = document.getElementById('aspect').value.split('/').map(Number);
  const resW  = +document.getElementById('resW').value;
  const resH  = +document.getElementById('resH').value;
  const lum   = +document.getElementById('lumens').value;
  const D     = +document.getElementById('dist').value;
  const minLux= +document.getElementById('minLux').value;
  const maxPx = +document.getElementById('maxPixel').value;
  const ovX   = +document.getElementById('ovx').value/100;
  const ovY   = +document.getElementById('ovy').value/100;
  const oMode = document.querySelector('input[name="orientMode"]:checked').value;
  const manCols = +document.getElementById('manCols').value;
  const manRows = +document.getElementById('manRows').value;

  // calcul des résultats temporaires
  const imgW = BW / (1 + (manCols - 1) * (1 - ovX));
  const imgH = imgW * (oMode === 'land' ? aH/aW : aW/aH);
  const pxW  = imgW * 1000 / resW;
  const pxH  = imgH * 1000 / resH;
  const luxA = lum * manCols * manRows / (BW * BH);
  const tr   = D / imgW;
  const foc  = tr * SENSOR_W;

  // Calcul de l'espace pixélaire temporaire
  const netWidth = imgW * manCols * resW * (1 - ovX);
  const netHeight = imgH * manRows * resH * (1 - ovY);
  const grossWidth = imgW * manCols * resW;
  const grossHeight = imgH * manRows * resH;

  tempLayout = { cols: manCols, rows: manRows, imgW, imgH, pxW, pxH, luxA, throw: tr, focale: foc, orientation: oMode, netResolution: `${netWidth.toFixed(0)} x ${netHeight.toFixed(0)}`, grossResolution: `${grossWidth.toFixed(0)} x ${grossHeight.toFixed(0)}` };

  // affichage
  drawCanvas(true);
  showTempResults();
}

function drawCanvas(useManual) {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  ctx.clearRect(0, 0, cv.width, cv.height);

  // bâtiment
  const BW = +document.getElementById('bldgW').value;
  const BH = +document.getElementById('bldgH').value;
  const pad = 60;
  const scale = Math.min((cv.width - 2 * pad) / BW, (cv.height - 2 * pad) / BH);
  const BWpx = BW * scale, BHpx = BH * scale;
  const bx = (cv.width - BWpx) / 2, by = (cv.height - BHpx) / 2;

  // dessine bâti
  ctx.fillStyle = 'rgba(255, 165, 0, 0.2)'; ctx.fillRect(bx, by, BWpx, BHpx);
  ctx.lineWidth = 4; ctx.strokeStyle = 'orange';
  ctx.strokeRect(bx, by, BWpx, BHpx);
  // dimensions texte
  ctx.fillStyle = '#000'; ctx.font = '16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
  ctx.fillText(`${BW.toFixed(2)} m`, bx + BWpx/2, by - 8);
  ctx.save();
    ctx.translate(bx - 8, by + BHpx/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(`${BH.toFixed(2)} m`, 0, 0);
  ctx.restore();

  // layout à dessiner
  const cols = useManual
    ? +document.getElementById('manCols').value
    : layout.cols;
  const rows = useManual
    ? +document.getElementById('manRows').value
    : layout.rows;
  const ovX = +document.getElementById('ovx').value / 100;
  const ovY = +document.getElementById('ovy').value / 100;
  // choisir ratio selon orientation
  const [aW,aH] = document.getElementById('aspect').value.split('/').map(Number);
  const ratio = layout.orientation === 'Paysage' ? aH/aW : aW/aH;

  const imgWm = BW / (1 + (cols - 1) * (1 - ovX));
  const imgHm = imgWm * ratio;
  const imgWpx = imgWm * scale, imgHpx = imgHm * scale;

  // centrer grille
  const covWpx = imgWpx + (cols - 1) * (imgWpx * (1 - ovX));
  const covHpx = imgHpx + (rows - 1) * (imgHpx * (1 - ovY));
  const startX = bx - (covWpx - BWpx) / 2;
  const startY = by - (covHpx - BHpx) / 2;

  // dessine projecteurs
  let idx = 0, total = cols * rows;
  const rects = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const x = startX + c * (imgWpx * (1 - ovX));
      const y = startY + r * (imgHpx * (1 - ovY));
      rects.push({x,y,w:imgWpx,h:imgHpx});
      // zone verte
      const multiplier = useManual ? 1 : layout.multiplier;
      const color = multiplier === 1 ? '#9cffac' :
                    multiplier === 2 ? '#00ff00' :
                    multiplier === 3 ? '#00b200' :
                    multiplier === 4 ? '#006b00' :
                    multiplier === 5 ? '#d8bfd8' :
                    multiplier === 6 ? '#ba68c8' :
                    multiplier === 7 ? '#9c27b0' :
                    '#4a148c';
      ctx.fillStyle = color;
      ctx.fillRect(x,y,imgWpx,imgHpx);
      // grille blanche
      ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1;
      const sx = imgWpx/10, sy = imgHpx/10;
      for (let i=1; i<10; i++){
        ctx.beginPath();
        ctx.moveTo(x+sx*i,y); ctx.lineTo(x+sx*i,y+imgHpx);
        ctx.moveTo(x,y+sy*i); ctx.lineTo(x+imgWpx,y+sy*i);
        ctx.stroke();
      }
      // contour coloré + numéro
      const hue = Math.round(idx * 360 / total);
      ctx.strokeStyle = `hsl(${hue},70%,40%)`;
      ctx.lineWidth = 2;
      ctx.strokeRect(x,y,imgWpx,imgHpx);
      ctx.fillStyle = '#000'; ctx.font='bold 14px Arial';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(`${idx+1}`, x+imgWpx/2, y+imgHpx/2);
      idx++;
    }
  }

  // dessine bâtiment par-dessus les matrices
  ctx.fillStyle = 'rgba(255, 165, 0, 0.2)';
  ctx.fillRect(bx, by, BWpx, BHpx);
  ctx.lineWidth = 4; ctx.strokeStyle = 'orange';
  ctx.strokeRect(bx, by, BWpx, BHpx);

  // overlap en bleu
  ctx.fillStyle='rgba(0,0,200,0.4)';
  for (let i=0; i<rects.length; i++){
    for (let j=i+1; j<rects.length; j++){
      const A=rects[i], B=rects[j];
      const ix=Math.max(A.x,B.x), iy=Math.max(A.y,B.y);
      const iw=Math.min(A.x+A.w,B.x+B.w)-ix;
      const ih=Math.min(A.y+A.h,B.y+B.h)-iy;
      if (iw>1 && ih>1) ctx.fillRect(ix,iy,iw,ih);
    }
  }
  // débordements en rouge
  ctx.fillStyle='rgba(200,0,0,0.3)';
  rects.forEach(r=>{
    if (r.x<bx)          ctx.fillRect(r.x, r.y, bx-r.x, r.h);
    if (r.x+r.w>bx+BWpx) ctx.fillRect(bx+BWpx, r.y, r.x+r.w-(bx+BWpx), r.h);
    if (r.y<by)          ctx.fillRect(r.x, r.y, r.w, by-r.y);
    if (r.y+r.h>by+BHpx) ctx.fillRect(r.x, by+BHpx, r.w, r.y+r.h-(by+BHpx));
  });
}

function showResults(){
  if (!layout) return;
  const R = layout;
  document.getElementById('results').textContent =
`Orientation    : ${R.orientation}
Projecteurs    : ${R.cols} × ${R.rows} = ${R.tot}
Image p/proj   : ${R.imgW.toFixed(2)} × ${R.imgH.toFixed(2)} m
Pixel (mm)     : ${R.pxW.toFixed(2)} × ${R.pxH.toFixed(2)}
Throw ratio    : ${R.throw.toFixed(2)} :1
Focale (mm)    : ${R.focale.toFixed(1)}
Lux moyen      : ${R.luxA.toFixed(0)} lx
Multiplicateur: ${R.multiplier}
Espace pixélaire net : ${R.netResolution}
Espace pixélaire brut : ${R.grossResolution}`;
}

function showTempResults(){
  if (!tempLayout) return;
  const R = tempLayout;
  document.getElementById('temp-results').textContent =
`Orientation    : ${R.orientation}
Projecteurs    : ${R.cols} × ${R.rows}
Image p/proj   : ${R.imgW.toFixed(2)} × ${R.imgH.toFixed(2)} m
Pixel (mm)     : ${R.pxW.toFixed(2)} × ${R.pxH.toFixed(2)}
Throw ratio    : ${R.throw.toFixed(2)} :1
Focale (mm)    : ${R.focale.toFixed(1)}
Lux moyen      : ${R.luxA.toFixed(0)} lx
Espace pixélaire net : ${R.netResolution}
Espace pixélaire brut : ${R.grossResolution}`;
  document.getElementById('temp-results').style.display = 'block';
}

</script>

</body>
</html>
